use super::{ScreenState, ScreenUpdateReceiver, TextFormatter, TextVertex};
use crate::{
    plugins::server::{ScreenUpdate, ScreenUpdateEvent, ScreenUpdateMessage},
    utils::graph::Graph,
};
use bevy::prelude::*;
use crossbeam_channel::{unbounded, Sender};
use futures_util::{future, StreamExt, TryStreamExt};
use regex::Regex;
use std::{collections::VecDeque, fs};
use tokio::{
    net::{TcpListener, TcpStream},
    runtime::Builder,
};
use tokio_tungstenite::tungstenite::Message;
use unicode_segmentation::UnicodeSegmentation;
use uuid::Uuid;

pub const WS_SERVER_ADDR: &str = "127.0.0.1:8380";

/// Set-ups the WebSocket server to accept connections
pub fn setup(mut commands: Commands) {
    let (tx, rx) = unbounded::<ScreenUpdate>();

    // Start the WebSocket server on a different thread
    std::thread::spawn(move || {
        Builder::new_current_thread()
            .enable_io()
            .build()
            .unwrap()
            .block_on(ws_server_runtime(tx));
    });

    commands.insert_resource(ScreenUpdateReceiver(rx));
}

/// Relays events generated by the WebSocket server to the bevy thread
pub fn events_relay(
    receiver: ResMut<ScreenUpdateReceiver>,
    mut events: EventWriter<ScreenUpdateEvent>,
) {
    for mcdu_event in receiver.try_iter() {
        events.send(ScreenUpdateEvent(mcdu_event));
    }
}

/// Set-ups the WebSocket server used to communicate with the MCDU
async fn ws_server_runtime(tx: Sender<ScreenUpdate>) {
    // Create the TCP listener and event loop that will accept connections
    let listener = TcpListener::bind(WS_SERVER_ADDR)
        .await
        .expect("Failed to bind");
    info!("Listening on {}", WS_SERVER_ADDR);

    while let Ok((stream, _)) = listener.accept().await {
        tokio::spawn(handle_connection(stream, tx.clone()));
    }
}

/// Accepts a new WebSocket connection and handles the client/server communication
async fn handle_connection(stream: TcpStream, tx: Sender<ScreenUpdate>) {
    // Accept a new WebSocket connection
    let remote_addr = stream.peer_addr().unwrap();
    let ws_stream = tokio_tungstenite::accept_async(stream)
        .await
        .expect("Failed to handshake");
    info!("New WebSocket connection from {}", remote_addr);

    let (_write, read) = ws_stream.split();

    // Handle incoming messages
    read.try_for_each(|ws_message| {
        if let Message::Text(msg) = ws_message {
            // Extract the command and (optional) data from the message sent by the MCDU
            let mut sections = msg.splitn(2, ":").collect::<VecDeque<&str>>();
            let (_command, data) = (sections.pop_front(), sections.pop_back());
            info!("MCDU message: {:?}", _command);

            // Handle commands
            if let Some(command) = _command {
                match command {
                    "update" => handle_update_command(tx.clone(), data),
                    _ => {}
                };
            }
        }

        future::ready(Ok(()))
    })
    .await
    .expect("Failed to handle WebSocket message");
}

/// Handles the "update" command sent by the MCDU
fn handle_update_command(tx: Sender<ScreenUpdate>, data: Option<&str>) {
    if data.is_none() {
        warn!("Missing update data");
        return;
    }

    // Replace unrenderable unicode character used as whitespace with a simple space
    let nbsp_regex = Regex::new(r"\u00A0").unwrap();
    let json_msg = nbsp_regex.replace_all(data.unwrap(), " ").to_string();

    // Construct and send the screen update event
    let raw_screen_update = parse_json_msg(&json_msg).unwrap();
    let screen_update = ScreenUpdate {
        lines: raw_screen_update
            .lines
            .iter()
            .map(|line| {
                // Parse the line and swap the right and center column (FlyByWire's A32NX mod
                // uses the following layout [left, right, center] to represent a line whereas
                // in this project I prefer to use [left, center, right])
                let mut line = line
                    .iter()
                    .map(|section| parse_raw_text(section.clone()))
                    .collect::<Vec<Graph<String, TextVertex, bool>>>();
                line.swap(1, 2);

                line
            })
            .collect(),
        scratchpad: parse_raw_text(raw_screen_update.scratchpad),
        title: parse_raw_text(raw_screen_update.title),
        title_left: parse_raw_text(raw_screen_update.title_left),
        arrows: raw_screen_update.arrows,
    };

    tx.send(screen_update).unwrap();
}

/// Parses the message in JSON format sent to the server
fn parse_json_msg(json: &str) -> Option<ScreenState> {
    match serde_json::from_str::<ScreenUpdateMessage>(json) {
        Ok(msg) => Some(msg.left),
        _ => None,
    }
}

/// Parses the formatter tags used by the FlyByWire's A32NX mod and returns a tree-like
/// representation of how text should be segmented in sections, each with their formatting and
/// content
fn parse_raw_text(raw_text: String) -> Graph<String, TextVertex, bool> {
    let mut current_text: String = raw_text;
    let mut current_parent: String = "root".to_string();
    let mut position = 0;

    // Create a new graph with a single node to use as root
    let mut graph: Graph<String, TextVertex, bool> = Graph::new();
    graph.push_vertex(current_parent.clone(), TextVertex::default());

    // Escape all {sp} self-closing tags with a whitespace
    let space_formatter_re = Regex::new(r"\{sp\}").unwrap();
    current_text = space_formatter_re.replace_all(current_text.as_str(), " ").to_string();

    while current_text.graphemes(true).count() > 0 {
        // Look for the beginning of a formatter tag
        let formatter_re = Regex::new(r"^(\{(?P<formatter>[a-zA-Z]+)\}(?P<rest>.*))").unwrap();
        match formatter_re.captures(current_text.as_str()) {
            Some(captures) => {
                // Split the formatter from the rest of the string
                let formatter = TextFormatter::from_str(&captures["formatter"]);
                let rest = &captures["rest"];

                // Update current references and skip to the next iteration if end tag is found
                if formatter == TextFormatter::End {
                    current_text = rest.to_string();
                    current_parent = graph.get_parent(current_parent.clone()).unwrap();
                    continue;
                }

                // Create a new vertex
                let vertex_id = Uuid::new_v4().to_string();
                let mut vertex = TextVertex {
                    formatters: vec![formatter],
                    value: None,
                    ..default()
                };

                // Inherit formatters from parent node
                if let Some(parent) = graph.get_vertex(current_parent.clone()) {
                    for formatter in parent.formatters.iter() {
                        vertex.formatters.push(formatter.clone());
                    }
                }

                // Register the vertex and its edges
                graph.push_vertex(vertex_id.clone(), vertex);
                graph.push_edge(current_parent.clone(), vertex_id.clone(), false);
                graph.push_edge(vertex_id.clone(), current_parent.clone(), true);

                current_text = rest.to_string();
                current_parent = vertex_id;
            }
            None => {
                // Extract the text to associate to the vertex that is currently being parsed
                let value: String = current_text
                    .graphemes(true)
                    .take_while(|c| *c != "{")
                    .collect();
                let value_len: usize = value.graphemes(true).map(|c| c.bytes().count()).sum();

                // Update the vertex
                let mut vertex = graph.get_vertex_mut(current_parent.clone()).unwrap();
                vertex.value = Some(value);
                vertex.position = position;
                position += 1;

                // Continue parsing after the text that has just been extracted
                let section = &current_text[(if value_len > 0 { value_len } else { 0 })..];
                current_text = section.to_string();
            }
        }
    }

    graph
}

fn load_test_message(tx: Sender<ScreenUpdate>) {
    let path = "test_message.json";
    let json_msg = fs::read_to_string(path).unwrap();

    handle_update_command(tx, Some(&json_msg));
}
